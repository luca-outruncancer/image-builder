// src/lib/server/transactionStorageServer.ts
// Server-side implementation of transaction storage utilities
// NOTE: This file should only be imported in server components and API routes

import { createClient } from '@supabase/supabase-js';
import { IMAGE_STATUS } from './imageStorageServer';

// Use environment variables for Supabase connection (server-side)
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

export interface TransactionRecord {
  transaction_id?: number;  // Auto-generated by DB
  image_id: number;
  sender_wallet: string;
  recipient_wallet: string;
  transaction_hash: string;
  transaction_status: string; // 'success', 'failed', 'pending', 'timeout'
  amount: number;
  token: string;
  timestamp?: string;  // Auto-generated by DB
  retry_count?: number; // Track retry attempts
  blockchain_confirmation?: boolean; // Whether confirmed on blockchain
}

export const TRANSACTION_STATUS = {
  SUCCESS: 'success',
  FAILED: 'failed',
  PENDING: 'pending',
  TIMEOUT: 'timeout'
};

// Initialize Supabase client for server-side operations
function getSupabaseClient() {
  if (!supabaseUrl || !supabaseKey) {
    console.error("Missing Supabase credentials in server environment");
    throw new Error("Supabase configuration is missing");
  }
  
  return createClient(supabaseUrl, supabaseKey);
}

/**
 * Save a transaction record and update the associated image status (server-side implementation)
 * @param record Transaction data to save
 * @returns Success indicator and data/error
 */
export async function saveTransactionServer(record: TransactionRecord) {
  try {
    console.log("[Server] Saving transaction to database:", record);
    
    const supabase = getSupabaseClient();
    
    // Validate transaction record
    if (!record.image_id || !record.transaction_hash || !record.amount) {
      return {
        success: false,
        error: "Invalid transaction record: missing required fields"
      };
    }
    
    // Get current timestamp
    const now = new Date().toISOString();
    
    // Get retry count (if this is a retry)
    let retryCount = 0;
    
    try {
      const { data: existingTx } = await supabase
        .from('transactions')
        .select('retry_count')
        .eq('image_id', record.image_id)
        .eq('transaction_status', TRANSACTION_STATUS.FAILED)
        .order('timestamp', { ascending: false })
        .limit(1)
        .single();
      
      if (existingTx?.retry_count !== undefined) {
        retryCount = existingTx.retry_count + 1;
        console.log(`[Server] Transaction for image ${record.image_id} is retry #${retryCount}`);
      }
    } catch (countError) {
      // It's okay if there's no previous transaction - this is the first attempt
      console.log("[Server] No previous transaction found, this is the first attempt");
    }
    
    // 1. Insert the transaction record
    const { data, error } = await supabase
      .from('transactions')
      .insert([{
        image_id: record.image_id,
        sender_wallet: record.sender_wallet,
        recipient_wallet: record.recipient_wallet,
        transaction_hash: record.transaction_hash,
        transaction_status: record.transaction_status || TRANSACTION_STATUS.SUCCESS,
        amount: record.amount,
        token: record.token,
        timestamp: now,
        retry_count: retryCount,
        blockchain_confirmation: record.blockchain_confirmation || true
      }])
      .select();
    
    if (error) {
      console.error("[Server] Supabase error saving transaction:", error);
      throw error;
    }
    
    console.log("[Server] Transaction saved successfully:", data);
    
    // 2. Update the image status based on transaction status
    let newImageStatus;
    let additionalFields = {};
    
    switch (record.transaction_status) {
      case TRANSACTION_STATUS.SUCCESS:
        newImageStatus = IMAGE_STATUS.CONFIRMED;
        additionalFields = { confirmed_at: now };
        break;
      case TRANSACTION_STATUS.FAILED:
        newImageStatus = IMAGE_STATUS.PAYMENT_FAILED;
        break;
      case TRANSACTION_STATUS.TIMEOUT:
        newImageStatus = IMAGE_STATUS.PAYMENT_TIMEOUT;
        break;
      case TRANSACTION_STATUS.PENDING:
        newImageStatus = IMAGE_STATUS.PENDING_PAYMENT;
        break;
      default:
        newImageStatus = IMAGE_STATUS.PENDING_PAYMENT;
    }
    
    // Update the image record
    const { error: updateError } = await supabase
      .from('images')
      .update({ 
        image_status: newImageStatus,
        last_updated_at: now,
        ...additionalFields
      })
      .eq('image_id', record.image_id);
    
    if (updateError) {
      console.error("[Server] Error updating image status after transaction:", updateError);
      return { 
        success: true, 
        warning: "Transaction saved but image status could not be updated",
        data 
      };
    }
    
    console.log(`[Server] Image ${record.image_id} status updated to ${newImageStatus}`);
    return { success: true, data };
  } catch (error) {
    console.error('[Server] Failed to save transaction:', error);
    return { success: false, error };
  }
}

/**
 * Get transactions for a specific image (server-side implementation)
 */
export async function getTransactionsByImageServer(imageId: number) {
  try {
    const supabase = getSupabaseClient();
    
    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .eq('image_id', imageId)
      .order('timestamp', { ascending: false });
    
    if (error) {
      throw error;
    }
    
    return { success: true, data };
  } catch (error) {
    console.error('[Server] Failed to get transactions for image:', error);
    return { success: false, error };
  }
}

/**
 * Mark a payment as timed out if it's been pending for too long (server-side implementation)
 */
export async function markPaymentAsTimedOutServer(imageId: number) {
  try {
    const supabase = getSupabaseClient();
    
    const now = new Date().toISOString();
    
    // Update image status
    const { error: imageError } = await supabase
      .from('images')
      .update({ 
        image_status: IMAGE_STATUS.PAYMENT_TIMEOUT,
        last_updated_at: now
      })
      .eq('image_id', imageId)
      .or(`image_status.eq.${IMAGE_STATUS.PENDING_PAYMENT},image_status.eq.${IMAGE_STATUS.PAYMENT_RETRY}`);
    
    if (imageError) {
      console.error("[Server] Error marking image payment as timed out:", imageError);
      throw imageError;
    }
    
    // Add a transaction record for the timeout
    const { error: txError } = await supabase
      .from('transactions')
      .insert([{
        image_id: imageId,
        sender_wallet: 'unknown', // We might not know this
        recipient_wallet: 'unknown', // Same here
        transaction_hash: 'timeout', // No actual hash
        transaction_status: TRANSACTION_STATUS.TIMEOUT,
        amount: 0, // We don't know the amount
        token: 'unknown', // We might not know this
        timestamp: now
      }]);
    
    if (txError) {
      console.error("[Server] Error creating timeout transaction record:", txError);
      // Don't throw, as the image status update was successful
    }
    
    return { success: true };
  } catch (error) {
    console.error('[Server] Failed to mark payment as timed out:', error);
    return { success: false, error };
  }
}
