// src/lib/transactionStorage.ts
'use client';

import { createClient } from '@supabase/supabase-js';
import { IMAGE_STATUS } from './imageStorage';

// Use environment variables for Supabase connection
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

let supabase: any = null;

try {
  if (supabaseUrl && supabaseKey) {
    supabase = createClient(supabaseUrl, supabaseKey);
    console.log("Supabase client initialized in transactionStorage");
  } else {
    console.error("Unable to initialize Supabase client due to missing environment variables in transactionStorage");
  }
} catch (error) {
  console.error("Error initializing Supabase client in transactionStorage:", error);
}

export interface TransactionRecord {
  transaction_id?: number;  // Auto-generated by DB
  image_id: number;
  sender_wallet: string;
  recipient_wallet: string;
  transaction_hash: string;
  transaction_status: string;
  amount: number;
  token: string;
  timestamp?: string;  // Auto-generated by DB
}

/**
 * Save a transaction record and update the associated image status
 * @param record Transaction data to save
 * @returns Success indicator and data/error
 */
export async function saveTransaction(record: TransactionRecord) {
  try {
    console.log("Saving transaction to database:", record);
    
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    // Begin transaction to ensure both operations succeed or fail together
    // Note: Supabase doesn't support true transactions in the JS client, so we do this sequentially
    
    // 1. Insert the transaction record
    const { data, error } = await supabase
      .from('transactions')
      .insert([{
        image_id: record.image_id,
        sender_wallet: record.sender_wallet,
        recipient_wallet: record.recipient_wallet,
        transaction_hash: record.transaction_hash,
        transaction_status: record.transaction_status,
        amount: record.amount,
        token: record.token,
        timestamp: new Date().toISOString()
      }])
      .select();
    
    if (error) {
      console.error("Supabase error saving transaction:", error);
      throw error;
    }
    
    console.log("Transaction saved successfully:", data);
    
    // 2. If transaction status is success, update the image status to confirmed
    if (record.transaction_status === 'success') {
      const { error: updateError } = await supabase
        .from('images')
        .update({ 
          image_status: IMAGE_STATUS.CONFIRMED,
          confirmed_at: new Date().toISOString()
        })
        .eq('image_id', record.image_id);
      
      if (updateError) {
        console.error("Error updating image status after successful transaction:", updateError);
        // Don't throw here - we still want to return the transaction data
      } else {
        console.log("Image status updated to CONFIRMED");
      }
    } else if (record.transaction_status === 'failed') {
      // If transaction failed, update image status accordingly
      const { error: updateError } = await supabase
        .from('images')
        .update({ 
          image_status: IMAGE_STATUS.PAYMENT_FAILED
        })
        .eq('image_id', record.image_id);
      
      if (updateError) {
        console.error("Error updating image status after failed transaction:", updateError);
      } else {
        console.log("Image status updated to PAYMENT_FAILED");
      }
    }
    
    return { success: true, data };
  } catch (error) {
    console.error('Failed to save transaction:', error);
    return { success: false, error };
  }
}

/**
 * Get transactions for a specific image
 */
export async function getTransactionsByImage(imageId: number) {
  try {
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .eq('image_id', imageId)
      .order('timestamp', { ascending: false });
    
    if (error) {
      throw error;
    }
    
    return { success: true, data };
  } catch (error) {
    console.error('Failed to get transactions for image:', error);
    return { success: false, error };
  }
}

/**
 * Get all transactions for a wallet address
 */
export async function getTransactionsByWallet(walletAddress: string) {
  try {
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .eq('sender_wallet', walletAddress)
      .order('timestamp', { ascending: false });
    
    if (error) {
      throw error;
    }
    
    return { success: true, data };
  } catch (error) {
    console.error('Failed to get transactions for wallet:', error);
    return { success: false, error };
  }
}

/**
 * Mark a payment as timed out if it's been pending for too long
 */
export async function markPaymentAsTimedOut(imageId: number) {
  try {
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    const { error } = await supabase
      .from('images')
      .update({ 
        image_status: IMAGE_STATUS.PAYMENT_TIMEOUT
      })
      .eq('image_id', imageId)
      .eq('image_status', IMAGE_STATUS.PENDING_PAYMENT);
    
    if (error) {
      console.error("Error marking payment as timed out:", error);
      throw error;
    }
    
    return { success: true };
  } catch (error) {
    console.error('Failed to mark payment as timed out:', error);
    return { success: false, error };
  }
}
