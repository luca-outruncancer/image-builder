// src/lib/transactionStorage.ts
'use client';

import { createClient } from '@supabase/supabase-js';
import { IMAGE_STATUS } from './imageStorage';

// Use environment variables for Supabase connection
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

let supabase: any = null;

try {
  if (supabaseUrl && supabaseKey) {
    supabase = createClient(supabaseUrl, supabaseKey);
    console.log("Supabase client initialized in transactionStorage");
  } else {
    console.error("Unable to initialize Supabase client due to missing environment variables in transactionStorage");
  }
} catch (error) {
  console.error("Error initializing Supabase client in transactionStorage:", error);
}

export interface TransactionRecord {
  transaction_id?: number;  // Auto-generated by DB
  image_id: number;
  sender_wallet: string;
  recipient_wallet: string;
  transaction_hash: string;
  transaction_status: string; // 'success', 'failed', 'pending', 'timeout'
  amount: number;
  token: string;
  timestamp?: string;  // Auto-generated by DB
  retry_count?: number; // Track retry attempts
  blockchain_confirmation?: boolean; // Whether confirmed on blockchain
}

export const TRANSACTION_STATUS = {
  SUCCESS: 'success',
  FAILED: 'failed',
  PENDING: 'pending',
  TIMEOUT: 'timeout',
  INITIATED: 'initiated', // New status for pre-committed transactions
  IN_PROGRESS: 'in_progress' // Status while blockchain transaction is processing
};

/**
 * Initialize a transaction record before blockchain interaction
 * @param imageId The ID of the image being processed
 * @param senderWallet The wallet address of the sender
 * @param recipientWallet The wallet address of the recipient 
 * @param amount The payment amount
 * @param token The token type (e.g., "SOL", "USDC")
 * @returns Success indicator, transaction ID, and any error
 */
export async function initializeTransaction(
  imageId: number,
  senderWallet: string,
  recipientWallet: string,
  amount: number,
  token: string
): Promise<{ success: boolean, transactionId?: number, error?: any }> {
  try {
    console.log(`Initializing transaction record for image ${imageId}`);
    
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    // Validate input data
    if (!imageId || !senderWallet || !recipientWallet || !amount || !token) {
      console.error("Missing required fields for transaction initialization");
      return {
        success: false,
        error: "Missing required fields for transaction initialization"
      };
    }
    
    // Get current timestamp
    const now = new Date().toISOString();
    
    // Create transaction record with INITIATED status
    const { data, error } = await supabase
      .from('transactions')
      .insert([{
        image_id: imageId,
        sender_wallet: senderWallet,
        recipient_wallet: recipientWallet,
        transaction_hash: 'pending', // Placeholder until real transaction is created
        transaction_status: TRANSACTION_STATUS.INITIATED,
        amount: amount,
        token: token,
        timestamp: now,
        retry_count: 0,
        blockchain_confirmation: false
      }])
      .select();
    
    if (error) {
      console.error("Supabase error initializing transaction:", error);
      throw error;
    }
    
    console.log("Transaction initialized successfully:", data[0]);
    
    // Update image status to indicate transaction initiation
    const { error: updateError } = await supabase
      .from('images')
      .update({ 
        image_status: IMAGE_STATUS.PENDING_PAYMENT,
        wallet_address: senderWallet, // Store wallet address with image
        last_updated_at: now
      })
      .eq('image_id', imageId);
    
    if (updateError) {
      console.error("Error updating image status after transaction initialization:", updateError);
      return { 
        success: true, 
        transactionId: data[0].transaction_id,
        error: "Transaction initialized but image status could not be updated"
      };
    }
    
    return { 
      success: true, 
      transactionId: data[0].transaction_id 
    };
  } catch (error) {
    console.error('Failed to initialize transaction:', error);
    return { success: false, error };
  }
}

/**
 * Update the status of an existing transaction
 * @param transactionId The ID of the transaction to update
 * @param status The new status
 * @param transactionHash Optional transaction hash (for completed transactions)
 * @returns Success indicator and any error
 */
export async function updateTransactionStatus(
  transactionId: number, 
  status: string,
  transactionHash?: string,
  blockchainConfirmation?: boolean
) {
  try {
    console.log(`Updating transaction ${transactionId} status to ${status}`);
    
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    const updateData: any = {
      transaction_status: status,
      last_updated_at: new Date().toISOString()
    };
    
    // Add transaction hash if provided
    if (transactionHash) {
      updateData.transaction_hash = transactionHash;
    }
    
    // Add blockchain confirmation if provided
    if (blockchainConfirmation !== undefined) {
      updateData.blockchain_confirmation = blockchainConfirmation;
    }
    
    const { error } = await supabase
      .from('transactions')
      .update(updateData)
      .eq('transaction_id', transactionId);
    
    if (error) {
      console.error("Supabase error updating transaction status:", error);
      throw error;
    }
    
    console.log(`Transaction ${transactionId} status updated to ${status}`);
    
    // If this is a final status, also update the image status
    if (status === TRANSACTION_STATUS.SUCCESS || status === TRANSACTION_STATUS.FAILED) {
      // Get the image ID for this transaction
      const { data: txData, error: txError } = await supabase
        .from('transactions')
        .select('image_id')
        .eq('transaction_id', transactionId)
        .single();
      
      if (txError) {
        console.error("Error getting image ID for transaction:", txError);
        return { 
          success: true, 
          warning: "Transaction status updated but could not update image status" 
        };
      }
      
      const imageId = txData.image_id;
      const newImageStatus = status === TRANSACTION_STATUS.SUCCESS 
        ? IMAGE_STATUS.CONFIRMED 
        : IMAGE_STATUS.PAYMENT_FAILED;
      
      const additionalFields = status === TRANSACTION_STATUS.SUCCESS 
        ? { confirmed_at: new Date().toISOString() } 
        : {};
      
      const { error: imageError } = await supabase
        .from('images')
        .update({ 
          image_status: newImageStatus,
          last_updated_at: new Date().toISOString(),
          ...additionalFields
        })
        .eq('image_id', imageId);
      
      if (imageError) {
        console.error("Error updating image status after transaction update:", imageError);
        return { 
          success: true, 
          warning: "Transaction status updated but image status could not be updated" 
        };
      }
    }
    
    return { success: true };
  } catch (error) {
    console.error('Failed to update transaction status:', error);
    return { success: false, error };
  }
}

/**
 * Save a transaction record and update the associated image status
 * @param record Transaction data to save
 * @returns Success indicator and data/error
 */
export async function saveTransaction(record: TransactionRecord) {
  try {
    console.log("Saving transaction to database:", record);
    
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    // Validate transaction record
    if (!record.image_id || !record.transaction_hash || !record.amount) {
      return {
        success: false,
        error: "Invalid transaction record: missing required fields"
      };
    }
    
    // Get current timestamp
    const now = new Date().toISOString();
    
    // Get retry count (if this is a retry)
    let retryCount = 0;
    
    try {
      const { data: existingTx } = await supabase
        .from('transactions')
        .select('retry_count')
        .eq('image_id', record.image_id)
        .eq('transaction_status', TRANSACTION_STATUS.FAILED)
        .order('timestamp', { ascending: false })
        .limit(1)
        .single();
      
      if (existingTx?.retry_count !== undefined) {
        retryCount = existingTx.retry_count + 1;
        console.log(`Transaction for image ${record.image_id} is retry #${retryCount}`);
      }
    } catch (countError) {
      // It's okay if there's no previous transaction - this is the first attempt
      console.log("No previous transaction found, this is the first attempt");
    }
    
    // 1. Insert the transaction record
    const { data, error } = await supabase
      .from('transactions')
      .insert([{
        image_id: record.image_id,
        sender_wallet: record.sender_wallet,
        recipient_wallet: record.recipient_wallet,
        transaction_hash: record.transaction_hash,
        transaction_status: record.transaction_status || TRANSACTION_STATUS.SUCCESS,
        amount: record.amount,
        token: record.token,
        timestamp: now,
        retry_count: retryCount,
        blockchain_confirmation: record.blockchain_confirmation || true
      }])
      .select();
    
    if (error) {
      console.error("Supabase error saving transaction:", error);
      throw error;
    }
    
    console.log("Transaction saved successfully:", data);
    
    // 2. Update the image status based on transaction status
    let newImageStatus;
    let additionalFields = {};
    
    switch (record.transaction_status) {
      case TRANSACTION_STATUS.SUCCESS:
        newImageStatus = IMAGE_STATUS.CONFIRMED;
        additionalFields = { confirmed_at: now };
        break;
      case TRANSACTION_STATUS.FAILED:
        newImageStatus = IMAGE_STATUS.PAYMENT_FAILED;
        break;
      case TRANSACTION_STATUS.TIMEOUT:
        newImageStatus = IMAGE_STATUS.PAYMENT_TIMEOUT;
        break;
      case TRANSACTION_STATUS.PENDING:
        newImageStatus = IMAGE_STATUS.PENDING_PAYMENT;
        break;
      default:
        newImageStatus = IMAGE_STATUS.PENDING_PAYMENT;
    }
    
    // Update the image record
    const { error: updateError } = await supabase
      .from('images')
      .update({ 
        image_status: newImageStatus,
        last_updated_at: now,
        ...additionalFields
      })
      .eq('image_id', record.image_id);
    
    if (updateError) {
      console.error("Error updating image status after transaction:", updateError);
      return { 
        success: true, 
        warning: "Transaction saved but image status could not be updated",
        data 
      };
    }
    
    console.log(`Image ${record.image_id} status updated to ${newImageStatus}`);
    return { success: true, data };
  } catch (error) {
    console.error('Failed to save transaction:', error);
    return { success: false, error };
  }
}

/**
 * Verify a transaction on the blockchain
 * @param transactionHash The transaction hash to verify
 * @returns Success indicator and verification status
 */
export async function verifyTransaction(transactionHash: string) {
  try {
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    // 1. First check if we have this transaction in our database
    const { data: txData, error: txError } = await supabase
      .from('transactions')
      .select('transaction_id, image_id, transaction_status')
      .eq('transaction_hash', transactionHash)
      .single();
    
    if (txError) {
      console.error("Error finding transaction:", txError);
      return { 
        success: false, 
        error: "Transaction not found in database" 
      };
    }
    
    // For a real implementation, we would call a blockchain API here
    // to verify the transaction status
    
    console.log(`Transaction ${transactionHash} verification skipped (would check blockchain API)`);
    
    // For now, we'll just mark it as verified in our database
    const { error: updateError } = await supabase
      .from('transactions')
      .update({ 
        blockchain_confirmation: true,
        last_verified_at: new Date().toISOString()
      })
      .eq('transaction_id', txData.transaction_id);
    
    if (updateError) {
      console.error("Error updating transaction confirmation:", updateError);
      return { 
        success: false, 
        error: "Failed to update transaction confirmation" 
      };
    }
    
    return { 
      success: true, 
      verified: true,
      data: txData
    };
  } catch (error) {
    console.error('Failed to verify transaction:', error);
    return { success: false, error };
  }
}

/**
 * Get transactions for a specific image
 */
export async function getTransactionsByImage(imageId: number) {
  try {
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .eq('image_id', imageId)
      .order('timestamp', { ascending: false });
    
    if (error) {
      throw error;
    }
    
    return { success: true, data };
  } catch (error) {
    console.error('Failed to get transactions for image:', error);
    return { success: false, error };
  }
}

/**
 * Get all transactions for a wallet address
 */
export async function getTransactionsByWallet(walletAddress: string) {
  try {
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .eq('sender_wallet', walletAddress)
      .order('timestamp', { ascending: false });
    
    if (error) {
      throw error;
    }
    
    return { success: true, data };
  } catch (error) {
    console.error('Failed to get transactions for wallet:', error);
    return { success: false, error };
  }
}

/**
 * Mark a payment as timed out if it's been pending for too long
 */
export async function markPaymentAsTimedOut(imageId: number) {
  try {
    if (!supabase) {
      console.warn("Skipping database operation: Supabase client not available");
      return { 
        success: false, 
        error: "Supabase client not available. Check your environment variables." 
      };
    }
    
    const now = new Date().toISOString();
    
    // Update image status
    const { error: imageError } = await supabase
      .from('images')
      .update({ 
        image_status: IMAGE_STATUS.PAYMENT_TIMEOUT,
        last_updated_at: now
      })
      .eq('image_id', imageId)
      .or(`image_status.eq.${IMAGE_STATUS.PENDING_PAYMENT},image_status.eq.${IMAGE_STATUS.PAYMENT_RETRY}`);
    
    if (imageError) {
      console.error("Error marking image payment as timed out:", imageError);
      throw imageError;
    }
    
    // Add a transaction record for the timeout
    const { error: txError } = await supabase
      .from('transactions')
      .insert([{
        image_id: imageId,
        sender_wallet: 'unknown', // We might not know this
        recipient_wallet: 'unknown', // Same here
        transaction_hash: 'timeout', // No actual hash
        transaction_status: TRANSACTION_STATUS.TIMEOUT,
        amount: 0, // We don't know the amount
        token: 'unknown', // We might not know this
        timestamp: now
      }]);
    
    if (txError) {
      console.error("Error creating timeout transaction record:", txError);
      // Don't throw, as the image status update was successful
    }
    
    return { success: true };
  } catch (error) {
    console.error('Failed to mark payment as timed out:', error);
    return { success: false, error };
  }
}